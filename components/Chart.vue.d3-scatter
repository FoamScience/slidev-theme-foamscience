<script setup lang="ts">
import { ref, computed, watch, onMounted, onUnmounted, nextTick } from 'vue'
import * as d3 from 'd3'
import { useChartTheming } from '../composables/useChartTheming'

export interface ChartDataset {
  label: string
  data: number[] | Array<{x: number, y: number, r?: number}>
}

export interface ChartData {
  labels?: string[]
  datasets: ChartDataset[]
}

interface Props {
  type?: 'line' | 'bar' | 'scatter' | 'bubble' | 'pie' | 'doughnut'
  data?: ChartData | string
  height?: number | string
  animationDuration?: number
}

const props = withDefaults(defineProps<Props>(), {
  type: 'line',
  height: 400,
  animationDuration: 1000
})

const svgRef = ref<SVGSVGElement | null>(null)
const containerRef = ref<HTMLDivElement | null>(null)
const loading = ref(false)
const error = ref<string | null>(null)
const chartData = ref<ChartData | null>(null)

const { getChartColors, hexToRgba, colors, isDark } = useChartTheming()

// Load data from JSON file or use provided data
const loadData = async () => {
  if (typeof props.data === 'string') {
    loading.value = true
    error.value = null

    try {
      const response = await fetch(props.data)
      if (!response.ok) {
        throw new Error(`Failed to load data: ${response.statusText}`)
      }
      const jsonData = await response.json()
      chartData.value = jsonData
    } catch (err) {
      error.value = `Error loading chart data: ${err}`
      console.error('Chart data loading error:', err)
    } finally {
      loading.value = false
    }
  } else if (props.data) {
    chartData.value = props.data
  }
}

const margin = { top: 40, right: 40, bottom: 60, left: 60 }

const createLineChart = (svg: d3.Selection<SVGSVGElement, unknown, null, undefined>, data: ChartData, width: number, height: number) => {
  if (!data.labels || !data.datasets || data.datasets.length === 0) return

  const chartColors = getChartColors(data.datasets.length)

  // Create scales
  const x = d3.scalePoint()
    .domain(data.labels)
    .range([margin.left, width - margin.right])
    .padding(0.5)

  const allValues = data.datasets.flatMap(d => d.data as number[])
  const y = d3.scaleLinear()
    .domain([0, d3.max(allValues) || 100])
    .nice()
    .range([height - margin.bottom, margin.top])

  // Add axes
  svg.append('g')
    .attr('transform', `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x))
    .attr('color', colors.value.text)
    .selectAll('text')
    .style('font-size', '12px')
    .style('font-family', 'Nunito Sans, sans-serif')

  svg.append('g')
    .attr('transform', `translate(${margin.left},0)`)
    .call(d3.axisLeft(y))
    .attr('color', colors.value.text)
    .selectAll('text')
    .style('font-size', '12px')
    .style('font-family', 'Nunito Sans, sans-serif')

  // Add gridlines
  svg.append('g')
    .attr('class', 'grid')
    .attr('transform', `translate(${margin.left},0)`)
    .call(d3.axisLeft(y)
      .tickSize(-(width - margin.left - margin.right))
      .tickFormat(() => '')
    )
    .attr('color', colors.value.overlay0)
    .attr('opacity', 0.1)

  // Draw lines
  data.datasets.forEach((dataset, i) => {
    const line = d3.line<number>()
      .x((d, idx) => x(data.labels![idx]) || 0)
      .y(d => y(d))
      .curve(d3.curveMonotoneX)

    const path = svg.append('path')
      .datum(dataset.data as number[])
      .attr('fill', 'none')
      .attr('stroke', chartColors[i])
      .attr('stroke-width', 2.5)
      .attr('d', line)

    // Animate line
    const totalLength = path.node()?.getTotalLength() || 0
    path
      .attr('stroke-dasharray', `${totalLength} ${totalLength}`)
      .attr('stroke-dashoffset', totalLength)
      .transition()
      .duration(props.animationDuration)
      .ease(d3.easeQuadInOut)
      .attr('stroke-dashoffset', 0)

    // Add points
    svg.selectAll(`.dot-${i}`)
      .data(dataset.data as number[])
      .enter()
      .append('circle')
      .attr('class', `dot-${i}`)
      .attr('cx', (d, idx) => x(data.labels![idx]) || 0)
      .attr('cy', d => y(d))
      .attr('r', 0)
      .attr('fill', chartColors[i])
      .transition()
      .delay((d, idx) => (idx / (dataset.data.length)) * props.animationDuration)
      .duration(200)
      .attr('r', 4)
  })

  // Add legend
  const legend = svg.append('g')
    .attr('transform', `translate(${width - margin.right - 150}, ${margin.top})`)

  data.datasets.forEach((dataset, i) => {
    const legendRow = legend.append('g')
      .attr('transform', `translate(0, ${i * 25})`)

    legendRow.append('rect')
      .attr('width', 15)
      .attr('height', 15)
      .attr('fill', chartColors[i])

    legendRow.append('text')
      .attr('x', 20)
      .attr('y', 12)
      .attr('fill', colors.value.text)
      .style('font-size', '13px')
      .style('font-family', 'Nunito Sans, sans-serif')
      .text(dataset.label)
  })
}

const createBarChart = (svg: d3.Selection<SVGSVGElement, unknown, null, undefined>, data: ChartData, width: number, height: number) => {
  if (!data.labels || !data.datasets || data.datasets.length === 0) return

  const chartColors = getChartColors(data.datasets.length)

  const x0 = d3.scaleBand()
    .domain(data.labels)
    .range([margin.left, width - margin.right])
    .padding(0.2)

  const x1 = d3.scaleBand()
    .domain(data.datasets.map((_, i) => i.toString()))
    .range([0, x0.bandwidth()])
    .padding(0.05)

  const allValues = data.datasets.flatMap(d => d.data as number[])
  const y = d3.scaleLinear()
    .domain([0, d3.max(allValues) || 100])
    .nice()
    .range([height - margin.bottom, margin.top])

  // Add axes
  svg.append('g')
    .attr('transform', `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x0))
    .attr('color', colors.value.text)
    .selectAll('text')
    .style('font-size', '12px')
    .style('font-family', 'Nunito Sans, sans-serif')

  svg.append('g')
    .attr('transform', `translate(${margin.left},0)`)
    .call(d3.axisLeft(y))
    .attr('color', colors.value.text)
    .selectAll('text')
    .style('font-size', '12px')
    .style('font-family', 'Nunito Sans, sans-serif')

  // Add gridlines
  svg.append('g')
    .attr('class', 'grid')
    .attr('transform', `translate(${margin.left},0)`)
    .call(d3.axisLeft(y)
      .tickSize(-(width - margin.left - margin.right))
      .tickFormat(() => '')
    )
    .attr('color', colors.value.overlay0)
    .attr('opacity', 0.1)

  // Draw bars
  const groups = svg.selectAll('.bar-group')
    .data(data.labels)
    .enter()
    .append('g')
    .attr('class', 'bar-group')
    .attr('transform', d => `translate(${x0(d)},0)`)

  data.datasets.forEach((dataset, i) => {
    groups.selectAll(`.bar-${i}`)
      .data(dataset.data as number[])
      .enter()
      .append('rect')
      .attr('class', `bar-${i}`)
      .attr('x', () => x1(i.toString()) || 0)
      .attr('y', height - margin.bottom)
      .attr('width', x1.bandwidth())
      .attr('height', 0)
      .attr('fill', chartColors[i])
      .transition()
      .duration(props.animationDuration)
      .ease(d3.easeQuadInOut)
      .attr('y', d => y(d))
      .attr('height', d => height - margin.bottom - y(d))
  })

  // Add legend
  const legend = svg.append('g')
    .attr('transform', `translate(${width - margin.right - 150}, ${margin.top})`)

  data.datasets.forEach((dataset, i) => {
    const legendRow = legend.append('g')
      .attr('transform', `translate(0, ${i * 25})`)

    legendRow.append('rect')
      .attr('width', 15)
      .attr('height', 15)
      .attr('fill', chartColors[i])

    legendRow.append('text')
      .attr('x', 20)
      .attr('y', 12)
      .attr('fill', colors.value.text)
      .style('font-size', '13px')
      .style('font-family', 'Nunito Sans, sans-serif')
      .text(dataset.label)
  })
}

const createScatterChart = (svg: d3.Selection<SVGSVGElement, unknown, null, undefined>, data: ChartData, width: number, height: number) => {
  if (!data.datasets || data.datasets.length === 0) return

  const chartColors = getChartColors(data.datasets.length)

  const allPoints = data.datasets.flatMap(d => d.data) as Array<{x: number, y: number}>
  const xExtent = d3.extent(allPoints, d => d.x) as [number, number]
  const yExtent = d3.extent(allPoints, d => d.y) as [number, number]

  const x = d3.scaleLinear()
    .domain(xExtent)
    .nice()
    .range([margin.left, width - margin.right])

  const y = d3.scaleLinear()
    .domain(yExtent)
    .nice()
    .range([height - margin.bottom, margin.top])

  // Add axes
  svg.append('g')
    .attr('transform', `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x))
    .attr('color', colors.value.text)
    .selectAll('text')
    .style('font-size', '12px')
    .style('font-family', 'Nunito Sans, sans-serif')

  svg.append('g')
    .attr('transform', `translate(${margin.left},0)`)
    .call(d3.axisLeft(y))
    .attr('color', colors.value.text)
    .selectAll('text')
    .style('font-size', '12px')
    .style('font-family', 'Nunito Sans, sans-serif')

  // Add gridlines
  svg.append('g')
    .attr('class', 'grid')
    .attr('transform', `translate(${margin.left},0)`)
    .call(d3.axisLeft(y)
      .tickSize(-(width - margin.left - margin.right))
      .tickFormat(() => '')
    )
    .attr('color', colors.value.overlay0)
    .attr('opacity', 0.1)

  svg.append('g')
    .attr('class', 'grid')
    .attr('transform', `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x)
      .tickSize(-(height - margin.top - margin.bottom))
      .tickFormat(() => '')
    )
    .attr('color', colors.value.overlay0)
    .attr('opacity', 0.1)

  // Draw points
  data.datasets.forEach((dataset, i) => {
    const points = dataset.data as Array<{x: number, y: number, r?: number}>

    svg.selectAll(`.scatter-${i}`)
      .data(points)
      .enter()
      .append('circle')
      .attr('class', `scatter-${i}`)
      .attr('cx', d => x(d.x))
      .attr('cy', d => y(d.y))
      .attr('r', 0)
      .attr('fill', hexToRgba(chartColors[i], 0.7))
      .attr('stroke', chartColors[i])
      .attr('stroke-width', 1.5)
      .transition()
      .duration(props.animationDuration)
      .ease(d3.easeQuadInOut)
      .attr('r', d => (props.type === 'bubble' && d.r) ? d.r : 5)
  })

  // Add legend
  const legend = svg.append('g')
    .attr('transform', `translate(${width - margin.right - 150}, ${margin.top})`)

  data.datasets.forEach((dataset, i) => {
    const legendRow = legend.append('g')
      .attr('transform', `translate(0, ${i * 25})`)

    legendRow.append('circle')
      .attr('cx', 7.5)
      .attr('cy', 7.5)
      .attr('r', 7.5)
      .attr('fill', chartColors[i])

    legendRow.append('text')
      .attr('x', 20)
      .attr('y', 12)
      .attr('fill', colors.value.text)
      .style('font-size', '13px')
      .style('font-family', 'Nunito Sans, sans-serif')
      .text(dataset.label)
  })
}

const createPieChart = (svg: d3.Selection<SVGSVGElement, unknown, null, undefined>, data: ChartData, width: number, height: number) => {
  if (!data.datasets || data.datasets.length === 0 || !data.labels) return

  const dataset = data.datasets[0]
  const chartColors = getChartColors(data.labels.length)

  const radius = Math.min(width, height) / 2 - margin.top
  const innerRadius = props.type === 'doughnut' ? radius * 0.6 : 0

  const g = svg.append('g')
    .attr('transform', `translate(${width / 2},${height / 2})`)

  const pie = d3.pie<number>()
    .value(d => d)
    .sort(null)

  const arc = d3.arc<d3.PieArcDatum<number>>()
    .innerRadius(innerRadius)
    .outerRadius(radius)

  const arcs = g.selectAll('.arc')
    .data(pie(dataset.data as number[]))
    .enter()
    .append('g')
    .attr('class', 'arc')

  arcs.append('path')
    .attr('fill', (d, i) => chartColors[i])
    .attr('stroke', colors.value.base)
    .attr('stroke-width', 2)
    .transition()
    .duration(props.animationDuration)
    .ease(d3.easeQuadInOut)
    .attrTween('d', function(d) {
      const interpolate = d3.interpolate({ startAngle: 0, endAngle: 0 }, d)
      return function(t) {
        return arc(interpolate(t)) || ''
      }
    })

  // Add labels
  arcs.append('text')
    .attr('transform', d => `translate(${arc.centroid(d)})`)
    .attr('text-anchor', 'middle')
    .attr('fill', colors.value.base)
    .style('font-size', '13px')
    .style('font-weight', 'bold')
    .style('font-family', 'Nunito Sans, sans-serif')
    .text((d, i) => data.labels![i])
    .style('opacity', 0)
    .transition()
    .delay(props.animationDuration)
    .duration(300)
    .style('opacity', 1)

  // Add legend
  const legend = svg.append('g')
    .attr('transform', `translate(${width - 150}, ${margin.top})`)

  data.labels.forEach((label, i) => {
    const legendRow = legend.append('g')
      .attr('transform', `translate(0, ${i * 25})`)

    legendRow.append('rect')
      .attr('width', 15)
      .attr('height', 15)
      .attr('fill', chartColors[i])

    legendRow.append('text')
      .attr('x', 20)
      .attr('y', 12)
      .attr('fill', colors.value.text)
      .style('font-size', '13px')
      .style('font-family', 'Nunito Sans, sans-serif')
      .text(label)
  })
}

const createChart = () => {
  if (!svgRef.value || !containerRef.value || !chartData.value) return

  const container = containerRef.value
  const width = container.clientWidth
  const height = container.clientHeight

  // Clear existing chart
  d3.select(svgRef.value).selectAll('*').remove()

  const svg = d3.select(svgRef.value)
    .attr('width', width)
    .attr('height', height)
    .attr('viewBox', `0 0 ${width} ${height}`)

  // Create chart based on type
  switch (props.type) {
    case 'line':
      createLineChart(svg, chartData.value, width, height)
      break
    case 'bar':
      createBarChart(svg, chartData.value, width, height)
      break
    case 'scatter':
    case 'bubble':
      createScatterChart(svg, chartData.value, width, height)
      break
    case 'pie':
    case 'doughnut':
      createPieChart(svg, chartData.value, width, height)
      break
  }
}

// Watch for data changes
watch(chartData, async (newData) => {
  if (newData) {
    await nextTick()
    createChart()
  }
})

// Watch for theme changes
watch(isDark, () => {
  createChart()
})

onMounted(async () => {
  await loadData()
  await nextTick()
  createChart()
})

// Expose method to update chart data programmatically
defineExpose({
  updateData: async (newData: ChartData) => {
    chartData.value = newData
    await nextTick()
    createChart()
  }
})
</script>

<template>
  <div class="chart-outer" :style="{ height: typeof height === 'number' ? `${height}px` : height }">
    <div class="chart-wrapper">
      <div v-if="loading" class="chart-loading">
        <div class="spinner"></div>
        <p>Loading chart data...</p>
      </div>

      <div v-else-if="error" class="chart-error">
        <p>{{ error }}</p>
      </div>

      <div v-else class="chart-container" ref="containerRef">
        <svg ref="svgRef"></svg>
      </div>
    </div>
  </div>
</template>

<style scoped>
.chart-outer {
  position: relative;
  width: 100%;
  overflow: hidden;
}

.chart-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
  padding: 1rem;
  background-color: color-mix(in srgb, var(--c-mantle) 50%, transparent);
  border-radius: 0.5rem;
  border: 1px solid var(--c-overlay0);
  overflow: hidden;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
}

.chart-container {
  position: relative;
  width: 100%;
  flex: 1;
  min-height: 0;
  overflow: hidden;
}

svg {
  display: block;
  width: 100%;
  height: 100%;
}

.chart-loading,
.chart-error {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--c-text);
}

.chart-error {
  color: var(--c-red);
}

.chart-error p {
  margin: 0;
  padding: 1rem;
  background-color: color-mix(in srgb, var(--c-red) 20%, transparent);
  border: 1px solid var(--c-red);
  border-radius: 0.375rem;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid var(--c-surface0);
  border-top-color: var(--c-blue);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 1rem;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}
</style>
